<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Codeforces-Global-Round-25</title>
    <link href="/2024/04/22/cf-global-round-25/"/>
    <url>/2024/04/22/cf-global-round-25/</url>
    
    <content type="html"><![CDATA[<h2id="c.-ticket-hoarding"><a href="https://codeforces.com/contest/1951/problem/C">C.Ticket Hoarding</a></h2><h3 id="题意">题意</h3><p>给定一个长度为<span class="math inline">\(n\)</span>的<strong>正整数</strong>数组 <spanclass="math inline">\(a\)</span>，求一个<strong>正整数</strong>数组<span class="math inline">\(b\)</span>在满足<spanclass="math inline">\(\sum_{i=1}^{n} b_i\)</span>=k的条件下，求<spanclass="math inline">\(\sum_{i=1}^n b_i(a_i +\sum_{j=1}^{i-1}b_i)\)</span>的最小值。</p><h3 id="解题思路">解题思路</h3><p>将上述式子进行变形：</p><p><span class="math display">\[\begin{align*} \sum_{i=1}^n b_i(a_i +\sum_{j=1}^{i-1}b_i) &amp;= \sum_{i=1}^n a_i b_i + \sum_{i=1}^n\sum_{j=1}^{i-1}b_i \\&amp;= \sum_{i=1}^n a_i b_i +\frac{1}{2}(\sum_{i=1}^n b_i)^2 - \frac{1}{2}\sum_{i=1}^n b_i^2 \\&amp;=\sum_{i=1}^n (a_i-\frac{1}{2}b_i)b_i + \frac{1}{2} k^2 \\&amp;=\frac{1}{2}\sum_{i=1}^n (a_i^2-(b_i-a_i)^2) +\frac{1}{2} k^2 \\&amp;=-\frac{1}{2} \sum_{i=1}^n (b_i-a_i)^2 + \frac{1}{2}\sum_{i=1}^n a_i^2 +\frac{1}{2} k^2 \end{align*}\]</span></p><p>故要使上式值最小，则应使<span class="math inline">\(\sum_{i=1}^n(b_i-a_i)^2\)</span>尽可能的大，而要使<spanclass="math inline">\(\sum_{i=1}^n (b_i-a_i)^2\)</span>尽可能的大，</p><p>等价于：较小的<spanclass="math inline">\(a_i\)</span>尽可能匹配较大的<spanclass="math inline">\(b_i\)</span>，较大的<spanclass="math inline">\(a_i\)</span>尽可能匹配较小的<spanclass="math inline">\(b_i\)</span></p><p>由此可通过将<spanclass="math inline">\(a\)</span>进行排序(从小到大)，将<spanclass="math inline">\(b\)</span>的前<spanclass="math inline">\(\lfloor\frac{k}{m}\rfloor\)</span>项置<spanclass="math inline">\(m\)</span>，第<spanclass="math inline">\(\lfloor\frac{k}{m}\rfloor+1\)</span>项置<spanclass="math inline">\(k%m\)</span>,后面全置<spanclass="math inline">\(0\)</span>，可得到最优解</p><h3 id="解题代码">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n,m,k;<br>  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>  <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>  ll ans=<span class="hljs-number">1ll</span>*k*k;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k&gt;=m)&#123;<br>      ans-=<span class="hljs-number">1ll</span>*(m-a[i])*(m-a[i]);<br>      k-=m;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>      ans-=<span class="hljs-number">1ll</span>*(k-a[i])*(k-a[i]);<br>      k=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> ans-=<span class="hljs-number">1ll</span>*a[i]*a[i];<br>    ans+=<span class="hljs-number">1ll</span>*a[i]*a[i];<br>  &#125;<br>  cout&lt;&lt;ans/<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces(1200-1400)训练</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>思维题训练5</title>
    <link href="/2023/11/24/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%835/"/>
    <url>/2023/11/24/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%835/</url>
    
    <content type="html"><![CDATA[<h2id="hamon-odyssey"><a href="https://codeforces.com/contest/1847/problem/B" target="_blank">HamonOdyssey</a></h2><h3 id="题意">题意</h3><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<spanclass="math inline">\(a\)</span>，请你将数组划分为若干<strong>连续的段</strong>，<strong>要求每一段的逻辑与的结果之和最小</strong>，<strong>问最多划分为多少段</strong></p><h3 id="解题思路">解题思路</h3><p>根据位与性质：<strong>连续位与操作只会让结果不变或变小</strong></p><p>由此我们可以得出结论：每一段的逻辑与的结果之和的最小值=将整个数组相与的结果</p><ul><li>若这个最小值大于<spanclass="math inline">\(0\)</span>，则最多划分成<spanclass="math inline">\(1\)</span>段(<strong>因为如果划分成多个段必然会使结果变大</strong>)</li><li>若这个最小值等于<spanclass="math inline">\(0\)</span>，可以采取贪心策略的去划分尽可能多的段：如果一段逻辑与结果为<spanclass="math inline">\(0\)</span>，立即切断，若最后一段不为<spanclass="math inline">\(0\)</span>，则将其并到其前面一段中(因为<spanclass="math inline">\(0\And x=0\)</span>)，这样可以保证最终的结果为<spanclass="math inline">\(0\)</span></li></ul><h3 id="解题代码">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-type">int</span> sum=a[<span class="hljs-number">1</span>],res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        sum&amp;=a[i];<br>        <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>) res++,sum=a[i+<span class="hljs-number">1</span>];<span class="hljs-comment">//切断操作</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!res) res++;<span class="hljs-comment">//如果最后一段不为0，并入前一段中</span><br>    cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="and"><a href="https://codeforces.com/contest/1013/problem/B" target="_blank">And</a></h2><h3 id="题意-1">题意</h3><p>给定一个长度为 <span class="math inline">\(n(n≤100000)\)</span>的序列 <spanclass="math inline">\(a_i(a_i≤100000)\)</span>，并给定一个数$x(x≤100000) $ 每一步可以将序列中的一个数与上 <spanclass="math inline">\(x\)</span>求使序列中出现两个相等的数的最小步数。如果不可能则输出 <spanclass="math inline">\(−1\)</span></p><h3 id="解题思路-1">解题思路</h3><p>根据位与性质：<span class="math inline">\(a_i\And x\And x \And \cdots\And x=\begin{cases}a_i &amp;a_i=a_i\And x\\a_i\And x &amp;a_i\neq a_i\And x\end{cases}\)</span></p><p>因此最多可以分为四种情况：</p><ul><li>步数为<spanclass="math inline">\(0\)</span>:原序列中本身存在相等的数</li><li>步数为<spanclass="math inline">\(1\)</span>:原序列存在一个数，与变换后的序列(<spanclass="math inline">\(a_i=a_i\And x(1\le i\len)\)</span>)中的数相等，同时要求<span class="math inline">\(a_i\ne a_i\And x\)</span></li><li>步数为<spanclass="math inline">\(2\)</span>:变换后的序列中存在相等的数</li><li>步数为<spanclass="math inline">\(-1\)</span>(即:不存在)：上述情况均不满足</li></ul><h3 id="解题代码-1">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; ma,mb;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        ma[a[i]]++,mb[a[i]&amp;x]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ma[a[i]]&gt;=<span class="hljs-number">2</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ma[a[i]&amp;x]&amp;&amp;(a[i]&amp;x)!=a[i])&#123;<br>            cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:mb)&#123;<br>        <span class="hljs-keyword">if</span>(it.second&gt;=<span class="hljs-number">2</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="m-arrays"><a href="https://codeforces.com/problemset/problem/1497/B" target="_blank">M-arrays</a></h2><h3 id="题意-2">题意</h3><p>给你一个长度为<span class="math inline">\(n\)</span>的数组<spanclass="math inline">\(a\)</span>和一个整数<spanclass="math inline">\(m\)</span></p><p>可以将这个数组的元素分成几个新的数组</p><p>在新数组中，可以改变需要排列元素的顺序，要求新数组中的相邻元素<spanclass="math inline">\(b_i,b_i+1\)</span>必须满足<spanclass="math inline">\((b_i+b_{i+1})\%m=0\)</span></p><p>求满足条件的新数组的<strong>最小个数</strong></p><h3 id="解题思路-2">解题思路</h3><p><span class="math inline">\((b_i+b_{i+1})\%m=0 \Longleftrightarrowb_i\%m+b_{i+1}\%m=m(b_i\ge 0,0\le i &lt; n)\)</span></p><p>由此，得出我们的最佳分组策略：</p><ul><li>将<span class="math inline">\(b_i\%m=0\)</span>的数或者<spanclass="math inline">\(b_i\%m=m/2(m为偶数)\)</span>的数需单独分入一个组中</li><li>将<spanclass="math inline">\(b_i\%m=x\)</span>的数(记其数量为：<spanclass="math inline">\(num_x\ne0\)</span>)和<spanclass="math inline">\(b_i\%m=m-x\)</span>的数(记其数量为：<spanclass="math inline">\(num_y\ne0\)</span>)放入同一组中，放入形式形如:<spanclass="math inline">\(x,y,x,y,x(num_x&gt;num_y)\)</span>这样交替排列，<strong>剩余不能放入<spanclass="math inline">\(x,y\)</span>交替排列的组的数只能单个成组</strong>，最终可以推出由<spanclass="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>构成的最小组数<spanclass="math inline">\(cnt=\begin{cases}|num_x-num_y| &amp;num_x\nenum_y\\1 &amp;num_x=num_y\end{cases}\)</span></li><li>不满足上述两种条件的其他元素均需单独成组</li></ul><p>我们将数组中的元素中模上<spanclass="math inline">\(m\)</span>放入结果为<spanclass="math inline">\(0,1,\cdots,m-1\)</span>的桶中</p><h3 id="解题代码-2">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(m+<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        num[x%m]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">if</span>((i==<span class="hljs-number">0</span>||i*<span class="hljs-number">2</span>==m)&amp;&amp;num[i]) res++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[i])&#123;<br>            <span class="hljs-keyword">if</span>(num[m-i]) <br>            res+=num[m-i]!=num[i]?<span class="hljs-built_in">abs</span>(num[m-i]-num[i]):<span class="hljs-number">1</span>,num[m-i]=num[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> res+=num[i];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="flip-the-bits"><a href="https://codeforces.com/contest/1504/problem/B" target="_blank">Flip the Bits</a></h2><h3 id="题意-3">题意</h3><p>给定长度为<span class="math inline">\(n\)</span>的<spanclass="math inline">\(01\)</span>串<spanclass="math inline">\(a,b\)</span>中，可以进行操作: 当前缀中<spanclass="math inline">\(0\)</span>与<spanclass="math inline">\(1\)</span>的个数相等时，可以将前缀进行翻转(<spanclass="math inline">\(0\rightarrow 1\)</span>，<spanclass="math inline">\(1\rightarrow0\)</span>)，问是否通过若干个操作使得<spanclass="math inline">\(a\rightarrow b\)</span></p><h3 id="解题思路-3">解题思路</h3><p>我们可以考虑通过将<spanclass="math inline">\(a,b\)</span>字符串进行按位异或,得到字符串<spanclass="math inline">\(c\)</span>(若<spanclass="math inline">\(c_i=0\)</span>,则说明<spanclass="math inline">\(i\)</span>位置<span class="math inline">\(a_i\neb_i\)</span>，反之则说明<spanclass="math inline">\(a_i=b_i\)</span>)</p><p>若前缀能翻转：</p><ul><li>翻转后不影响前缀中<spanclass="math inline">\(0,1\)</span>的相对数量，意味着能翻转的前缀永远能翻转，不能翻转的前缀永远不能翻转</li><li>翻转后不影响字符串前缀之后的字符，翻转大前缀必然影响小前缀</li></ul><p>初始前缀中元素被翻转的次数<spanclass="math inline">\(sum=0\)</span></p><p>从后往前遍历(翻转后面的必然影响前面的字符)：</p><ul><li>若<span class="math inline">\(!(sum\%2\ XOR \c[i])=true\)</span>(说明之前的翻转使得<spanclass="math inline">\(c_i=1\)</span>)，则需将以<spanclass="math inline">\(i\)</span>结尾的前缀翻转，若不能翻转(判断前缀是否能翻转可以进行预处理出前缀中<spanclass="math inline">\(0\)</span>与<spanclass="math inline">\(1\)</span>的数量是否相等)，则说明<spanclass="math inline">\(a\)</span>不能变换成<spanclass="math inline">\(b\)</span>,反之，则<spanclass="math inline">\(sum++\)</span>(表示<spanclass="math inline">\(i\)</span>前面的字符翻转次数将增加<spanclass="math inline">\(1\)</span>)</li><li>反之，则跳过</li></ul><h3 id="解题代码-3">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    string s,t;<br>    cin&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span>,<span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>,y=t[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        a[i]=x^y;<br>        cnt+=x;<br>        flag[i]=(<span class="hljs-number">2</span>*cnt==i+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(!(a[i]^(sum%<span class="hljs-number">2</span>))) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!flag[i])&#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        sum++;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2id="find-the-array"><a href="https://codeforces.com/contest/1550/problem/A" target="_blank">FindThe Array</a></h2><h3 id="题意-4">题意</h3><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(S=\sum_{i=1}^{n}a_i\)</span>，试构造一个<spanclass="math inline">\(b\)</span>数组，同时满足：</p><ul><li><span class="math inline">\(b_i|b_i+1\)</span>或<spanclass="math inline">\(b_{i+1}|b_i\)</span></li><li><span class="math inline">\(2\sum_{i=1}^{n}|a_i-b_i|\leS\)</span></li></ul><h3 id="解题思路-4">解题思路</h3><p>可以构造<span class="math inline">\(b\)</span>数组各元素之间呈<spanclass="math inline">\(2^k\)</span>的倍数关系，即可满足：(<spanclass="math inline">\(b_i|b_{i+1}\)</span>或<spanclass="math inline">\(b_{i+1}|b_i\)</span>)，<spanclass="math inline">\(b_i\)</span>选取为离<spanclass="math inline">\(a_i\)</span>最近的<spanclass="math inline">\(2^t\)</span>,即满足<spanclass="math inline">\(|a_i-b_i|\le a_i\Longrightarrow 2\sum_{i=1}^{n}|a_i-b_i|\le S\)</span></p><h3 id="解题代码-4">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(res&lt;x) res&lt;&lt;=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res&gt;&gt;<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        ll x;<br>        cin&gt;&gt;x;<br>        cout&lt;&lt;<span class="hljs-built_in">f</span>(x)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces(rating 1200-1600)思维题训练题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp</title>
    <link href="/2023/11/09/kmp/"/>
    <url>/2023/11/09/kmp/</url>
    
    <content type="html"><![CDATA[<h2 id="kmp算法"><span class="math inline">\(KMP\)</span>算法</h2><blockquote><p>求解给定一个模式串<spanclass="math inline">\(P\)</span>和一个主串<spanclass="math inline">\(S\)</span>，求模式串<spanclass="math inline">\(P\)</span>在主串<spanclass="math inline">\(S\)</span>中出现的位置(字符串的下标均从1开始)</p></blockquote><h3 id="算法思路">算法思路</h3><ol type="1"><li>取最长的相等前后缀，可以保证不漏解</li><li>通过模式串前后缀的自我匹配的长度，计算<spanclass="math inline">\(next\)</span>函数，给<spanclass="math inline">\(j\)</span>指针打一张表，失配时就跳到<spanclass="math inline">\(next[j]\)</span>的位置继续匹配</li></ol><blockquote><p><span class="math inline">\(next\)</span>函数：<spanclass="math inline">\(next[i]\)</span>表示模式串<spanclass="math inline">\(P[1,i]\)</span>中相等前后缀的最长长度</p></blockquote><h3 id="如何计算next函数"><strong>如何计算<spanclass="math inline">\(next\)</span>函数</strong></h3><blockquote><p>双指针：<span class="math inline">\(i\)</span>扫描模式串，<spanclass="math inline">\(j\)</span>扫描前缀</p><p>初始化：<span class="math inline">\(ne[i]=0,i=2,j=0\)</span></p><ol type="1"><li>若<span class="math inline">\(P[i]\ne P[j+1]\)</span>，让<spanclass="math inline">\(j\)</span>回跳能匹配的位置，如果找不到能匹配的位置，<spanclass="math inline">\(j\)</span>回跳到<spanclass="math inline">\(0\)</span></li><li>若<span class="math inline">\(P[i]=P[j+1]\)</span>，让<spanclass="math inline">\(j++\)</span>,指向匹配前缀的末尾</li><li><span class="math inline">\(next[i]\)</span>等于<spanclass="math inline">\(j\)</span>的值</li></ol></blockquote><h3 id="计算next函数模板">计算<spanclass="math inline">\(next\)</span>函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ne[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>    <span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>    ne[i]=j;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度分析">时间复杂度分析</h3><blockquote><p><spanclass="math inline">\(j\)</span>指针所走的总步数就决定了总的执行次数</p><p>每轮<span class="math inline">\(for\)</span>循环，<spanclass="math inline">\(j\)</span>至多<spanclass="math inline">\(+1\)</span>，那么<spanclass="math inline">\(j\)</span>一共向右至多走<spanclass="math inline">\(n\)</span>步，往左跳的步数加起来不会超过<spanclass="math inline">\(n\)</span>步，否则<spanclass="math inline">\(j\)</span>变为负数</p><p>故<span class="math inline">\(j\)</span>的总步数不会超过<spanclass="math inline">\(2n\)</span>，所以时间复杂度为<spanclass="math inline">\(O(n)\)</span></p></blockquote><h3 id="kmp模式串与主串匹配算法模板"><spanclass="math inline">\(KMP\)</span>模式串与主串匹配算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>    <span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>    <span class="hljs-keyword">if</span>(j==n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-n+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2023/11/09/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2023/11/09/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="双指针理论部分">1.双指针理论部分</h2><p>双指针是一个常用的优化技巧，是一种通过设置两个指针不断进行单向移动用来解决<strong>序列的区间问题</strong></p><p>两个指针<spanclass="math inline">\(i,j\)</span>，有两种扫描方向：</p><ol type="1"><li>同向扫描(快慢指针)：<spanclass="math inline">\(i,j\)</span>方向相同，都从头到尾，一个走的慢，一个走快</li><li>反向扫描:<spanclass="math inline">\(i,j\)</span>方向相反，一个从头到尾，一个从尾到头，在中间相会</li></ol><p><strong>双指针的核心：找单调关系：<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>的之间关系</strong></p><h3id="如何判断一个题目是否可以用双指针来解">(1)如何判断一个题目是否可以用双指针来解</h3><ol type="1"><li><p>因为双指针算法是一种优化时间复杂度的方法，所以我们可以首先写出最朴素的<strong>两层循环</strong>的写法。</p></li><li><p>然后考虑题目中是否具有<strong>单调性</strong>。</p></li></ol><p><strong>即当其中一个指针<spanclass="math inline">\(i\)</span>向后移动时，在希望得到答案的情况下，另一个指针<spanclass="math inline">\(j\)</span>是不是只能向着一个方向移动。</strong></p><ol start="3" type="1"><li>如果是，说明题目具有单调性，可以通过<strong>双指针算法优化</strong>。</li></ol><h3 id="双指针模板">(2)双指针模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&lt;i&amp;&amp;<span class="hljs-built_in">check</span>(i,j)) j++;<br>    <span class="hljs-comment">//每道题目具体逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针题目题解">2.双指针题目题解</h2><h3id="最长连续不重复子序列">(1).<a href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列 </a></h3><h4 id="题意">题意</h4><p>给定一个长度为 <span class="math inline">\(n\)</span>的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度</p><h4 id="解题思路">解题思路</h4><p>假设区间<span class="math inline">\([j,i]\)</span>是以<spanclass="math inline">\(i\)</span>为终点的最长连续不重复子序列</p><p>不难发现，若<span class="math inline">\(i\)</span>向后移动(<spanclass="math inline">\(eg:i+1\)</span>)，<spanclass="math inline">\(j\)</span>只会向后或不移动，<spanclass="math inline">\(j\)</span>不可能往前移动</p><p>证明如下：</p><p>假设 <span class="math inline">\([j,i]\)</span> 是以<spanclass="math inline">\(i\)</span>为终点的最长连续不重复子序列。如果当<spanclass="math inline">\(i\)</span> 向后移动时(比如到 <spanclass="math inline">\(i+1\)</span>)，<spanclass="math inline">\(j\)</span>却向前移动了(比如到 <spanclass="math inline">\(j−1\)</span>)。 说明 <spanclass="math inline">\([j−1,i+1]\)</span> 是以 <spanclass="math inline">\(i+1\)</span>为终点的<strong>最长连续不重复子序列</strong>，换句话说：<spanclass="math inline">\([j−1,i+1]\)</span>范围内都<strong>没有重复元素</strong>。 即：以 <spanclass="math inline">\(i\)</span> 为终点的最长连续不重复子序列应该是<span class="math inline">\([j−1,i]\)</span> 而不是 <spanclass="math inline">\([j,i]\)</span>，与假设相矛盾 因此可证明：<strong>当<span class="math inline">\(i\)</span>向后移动时，<spanclass="math inline">\(j\)</span>不可能向前移动（可能不动，也可以向后，就是不可能向前）</strong></p><p><strong>由此我们可以用双指针在<spanclass="math inline">\(O(n)\)</span>时间复杂度解决该问题</strong></p><h4 id="解题代码">解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">100010</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        num[a[i]]++;<br>        <span class="hljs-keyword">while</span>(j&lt;i&amp;&amp;num[a[i]]&gt;<span class="hljs-number">1</span>) num[a[j]]--,j++;<br>        res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="xor-sum-2">(2).<a href="https://atcoder.jp/contests/arc098/tasks/arc098_b">Xor Sum 2</a></h3><h4 id="题意-1">题意</h4><p>给定一数组，求出满足<span class="math inline">\(a_l+\cdots+a_r=a_l\wedge \dots \wedge a_r\)</span><span class="math inline">\(l \ler\)</span>的<span class="math inline">\((l,r)\)</span>的数量</p><h4 id="解题思路-1">解题思路</h4><p>假设<spanclass="math inline">\([l,r]\)</span>为满足题意的最大区间：满足<spanclass="math inline">\(a_l+\cdots+a_r=a_l \wedge \dots \wedgea_r\)</span></p><p>当<span class="math inline">\(r\)</span>增大时，则有<spanclass="math inline">\(a_l+\cdots+a_r&gt;a_l \wedge \dots \wedgea_r\)</span>，<strong>由于异或和是不进位的加法，有</strong><spanclass="math inline">\(a_i+a_j \ge a_i \wedge a_j\)</span>，只有<spanclass="math inline">\(l\)</span>增大才能使得<spanclass="math inline">\(a_l+\cdots+a_r=a_l \wedge \dots \wedgea_r\)</span></p><p>原因：当<span class="math inline">\(l\)</span>减小(<spanclass="math inline">\(eg:l-1\)</span>)时，根据性质<spanclass="math inline">\(a_i+a_j \ge a_i \wedge a_j\)</span>，<spanclass="math inline">\(a_{l-1}+(a_l+\cdots+a_r)&gt;a_{l-1} \wedge(a_l\wedge \cdots a_r)\)</span>恒成立</p><h4 id="解题代码-1">解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>  ll sum=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;<br>  ll res=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=n&amp;&amp;sum+a[j+<span class="hljs-number">1</span>]==(x^a[j+<span class="hljs-number">1</span>]))&#123;<br>      j++;<br>      sum+=a[j];<br>      x^=a[j];<br>    &#125;<br>    res+=j-i+<span class="hljs-number">1</span>;<br>    sum-=a[i];<br>    x^=a[i];<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3id="连续自然数和">(3).<a href="https://www.luogu.com.cn/problem/P1147" target="_blank">连续自然数和 </a></h3><h4 id="题意-2">题意</h4><p>对一个给定的正整数<em>M</em>，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为<em>M</em>。</p><h4 id="解题思路-2">解题思路</h4><p>假设<spanclass="math inline">\([l,r]\)</span>为满足连续自然数之和<spanclass="math inline">\(sum==M\)</span>的区间，则当<spanclass="math inline">\(r\)</span>增大时，则有该连续自然数之和<spanclass="math inline">\(sum&gt;M\)</span></p><ul><li><p>当<span class="math inline">\(l\)</span>减小时，<spanclass="math inline">\(sum\)</span>增大，<spanclass="math inline">\(sum&gt;M\)</span>恒成立</p></li><li><p>当<span class="math inline">\(l\)</span>增大时，<spanclass="math inline">\(sum\)</span>减小，<spanclass="math inline">\(sum==M\)</span>可能成立</p></li></ul><p>因此<span class="math inline">\(l\)</span>随着<spanclass="math inline">\(r\)</span>的增大而增大，满足单调性，可以使用双指针算法解决此题</p><h4 id="解题代码-2">解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;r&lt;m;r++)&#123;<br>        sum+=r;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;sum&gt;m)&#123;<br>            sum-=l,l++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum==m) <br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>codeforces思维题训练1</title>
    <link href="/2023/10/21/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%831/"/>
    <url>/2023/10/21/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%831/</url>
    
    <content type="html"><![CDATA[<h2id="consecutive-points-segment"><a href="https://codeforces.com/problemset/problem/1671/b" target="_blank">ConsecutivePoints Segment</a></h2><h3 id="题意">题意</h3><p>在 <span class="math inline">\(X\)</span>轴上给出 <spanclass="math inline">\(N\)</span> 个横坐标,每个点可以变为<spanclass="math inline">\(x_i-1\)</span>,<spanclass="math inline">\(x_i\)</span>,<spanclass="math inline">\(x_i+1\)</span>,问该序列最后是否可以变为一个接续序列</p><h3 id="解题思路">解题思路</h3><p>对于一段接续的点要保证其连续性，就必须将<strong>这段接续的点作为一个整体</strong>全部向左移动一格或向右移动一格</p><p>因此，在<spanclass="math inline">\(X\)</span>轴可以划分出若干条线段(各线段中间以<strong>空隙点</strong>将线段隔开)，并且<strong>最左侧线段最多只能右移一格，不能左移，最多能使空隙点数量减一，最右侧线段最多只能左移一格，不能右移，最多使空隙点数量减一</strong>，<strong>而移动中间线段将不改变空隙点数量</strong></p><p><strong>当空隙点数量为0时即认为序列变为一个接续序列</strong></p><p><strong>故只要<spanclass="math inline">\(X\)</span>轴的空隙点数量小于等于<spanclass="math inline">\(2\)</span>,就一定可以操作使序列变为接续序列，反之则不行</strong></p><h3 id="解题代码">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>  <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录空隙点数量</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    ans+=(a[i]-a[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(ans&lt;=<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>  <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> t;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题后思考">题后思考</h3><ul><li>在考虑单点操作时，可以将其多个点的共同操作，并且遵守某个原则(该题就是遵守保持接续性原则)</li><li>并且每次操作产生的影响，尽量用一个可以<strong>量化的东西来表达</strong>(该题中可以量化的东西为空隙点的数量)</li></ul><h2id="make-it-increasing"><a href="https://codeforces.com/problemset/problem/1667/a " target="_blank">Makeit Increasing</a></h2><h3 id="题意-1">题意</h3><p>给定一个长度为<span class="math inline">\(n\)</span>的数组<spanclass="math inline">\(a\)</span>，一个初始化全为<spanclass="math inline">\(0\)</span>长度亦为<spanclass="math inline">\(n\)</span>的数组<spanclass="math inline">\(b\)</span></p><p>可以进行操作：每次可以选择一个下标<spanclass="math inline">\(i\)</span>进行如下操作的其中一个</p><ul><li><span class="math inline">\(b[i]+=a[i]\)</span></li><li><span class="math inline">\(b[i]-=a[i]\)</span></li></ul><p>求使数组<spanclass="math inline">\(b\)</span>变为<strong>严格单增序列</strong>需操作的<strong>最少次数</strong></p><h3 id="解题思路-1">解题思路</h3><p>观察本题数据量不超过<spanclass="math inline">\(5000\)</span>，因此支持<spanclass="math inline">\(O(n^2)\)</span>做法</p><p>而要使<spanclass="math inline">\(b\)</span>数组变为严格单增序列且操作次数最少，必然肯定存在一个点<spanclass="math inline">\(k\)</span>，<spanclass="math inline">\([1,k]\)</span>区间进行减法操作，<spanclass="math inline">\([k+1,n]\)</span>进行加法操作</p><p><strong>那么<spanclass="math inline">\(c\)</span>数组中必然存在一个<spanclass="math inline">\(0\)</span></strong></p><p>因此我们通过枚举<spanclass="math inline">\(0\)</span>的位置，假设<spanclass="math inline">\(0\)</span>所在的位置为<spanclass="math inline">\(k\)</span>，在<spanclass="math inline">\([1,k-1]\)</span>进行减法操作保证左侧递增，记进行减法操作的数量为<spanclass="math inline">\(ans\)</span>，在<spanclass="math inline">\([k+1,n]\)</span>进行加法操作保证右侧递增,记进行加法操作的数量为<spanclass="math inline">\(bns\)</span></p><p>最终答案为<span class="math inline">\(res=max(ans+bns)\)</span></p><h3 id="解题代码-1">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span><span class="hljs-comment">//数据量小,暴力枚举位置计算即可，时间复杂度为：O(n^2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>  cin&gt;&gt;a[i];<br>  ll res=<span class="hljs-number">1e18</span>,ans=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;pos&lt;n;pos++)&#123;<br>    <span class="hljs-comment">//初始化b数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) b[i]=<span class="hljs-number">0</span>;<br>    ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//答案</span><br>    <span class="hljs-comment">//左边递减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>      ll d=b[i+<span class="hljs-number">1</span>]-b[i];<br>      ll k=(d+a[i])/a[i];<span class="hljs-comment">//递减倍数</span><br>      b[i]=k*a[i];<br>      ans+=k;<br>    &#125;<br>    <span class="hljs-comment">//右边递增</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos+<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>      ll d=b[i<span class="hljs-number">-1</span>]-b[i];<br>      ll k=(d+a[i])/a[i];<span class="hljs-comment">//递增倍数</span><br>      b[i]=k*a[i];<br>      ans+=k;<br>    &#125;<br>    res=<span class="hljs-built_in">min</span>(res,ans);<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="permutation"><a href="https://codeforces.com/problemset/problem/359/B" target="_blank">Permutation</a></h2><h3 id="题意-2">题意</h3><p>给定<span class="math inline">\(n,k\)</span>，构造一个排列使得<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=2k\)</span></p><h3 id="解题思路-2">解题思路</h3><p>对于构造排列，排列无非就三种：<strong>递增排列，递减排列，摆动排列</strong></p><p><strong>思考问题一般习惯从特殊一般来考虑</strong></p><ul><li>考虑特殊：</li></ul><p>假设<span class="math inline">\(a\)</span>为递增排列，那么<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=0\)</span></p><p>假设<span class="math inline">\(a\)</span>为递减排列，那么<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=0\)</span></p><ul><li>考虑一般：将特殊排列中的任意几个数调换位置即变为摆动摆列</li></ul><p>我们发现：</p><p>假设<span class="math inline">\(a\)</span>为递增排列，当每将一对<spanclass="math inline">\(a_{2i-1},a_{2i}\)</span>调换位置，将使得<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|\)</span>减少<spanclass="math inline">\(2\)</span></p><p>假设<span class="math inline">\(a\)</span>为递减排列，当每将一对<spanclass="math inline">\(a_{2i-1},a_{2i}\)</span>调换位置，将使得<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|\)</span>增加<spanclass="math inline">\(2\)</span></p><p>故要使得<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=2k\)</span></p><p>我们可以先使序列为递减序列，然后在此基础上选择k对<spanclass="math inline">\(a_{2i-1},a_{2i}\)</span>调换位置，即可使得<spanclass="math inline">\(\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=2k\)</span></p><h3 id="解题代码-2">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n,k;<br>  cin&gt;&gt;n&gt;&gt;k;<br>  vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>*n);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++) a[i]=<span class="hljs-number">2</span>*n-i;<span class="hljs-comment">//初始为递减序列</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">2</span>*i],a[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]);<span class="hljs-comment">//交换a[2*i],a[2*i+1]使式子等于2*k</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++)<br>  cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>  cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="lucky-chains"><a href="https://codeforces.com/problemset/problem/1766/D" target="_blank">LuckyChains</a></h2><h3 id="题意-3">题意</h3><p>定义二元组<spanclass="math inline">\((x,y)\)</span>是幸运的当且仅当<spanclass="math inline">\(gcd(x,y)=1\)</span></p><p>定义由<span class="math inline">\((x,y)\)</span>起始长度为<spanclass="math inline">\(k\)</span>的幸运链，当且仅当<spanclass="math inline">\(gcd(x+i,y+i)=1(0\le i \le k)\)</span>恒成立</p><p>若给定一个二元组<spanclass="math inline">\((x,y)\)</span>,求由它生成的最长幸运链的最长长度(若长度可以为<spanclass="math inline">\(\infty\)</span>，答案记为<spanclass="math inline">\(-1\)</span>)</p><h3 id="解题思路-3">解题思路</h3><p>假设从<spanclass="math inline">\((x,y)\)</span>开始，中间均是幸运的，直到<spanclass="math inline">\((x+t,y+t)\)</span>不幸运即：<spanclass="math inline">\(gcd(x+t,y+t)\ne 1\)</span></p><p>利用性质<spanclass="math inline">\(gcd(a,b)=gcd(a,b-a)\)</span>可得：</p><p><span class="math inline">\(gcd(x+t,y+t)=gcd(x+t,y-x)\)</span></p><p>易知：当<span class="math inline">\(x-y=1\)</span>时，<spanclass="math inline">\(t=\infty\)</span>,答案<spanclass="math inline">\(res=-1\)</span></p><p>当<span class="math inline">\(x-y \ne 1\)</span>时，则转变求<spanclass="math inline">\(t\)</span>的最小值</p><p>当<span class="math inline">\(gcd(a,b)\ne 1\)</span>时，那么<spanclass="math inline">\(a,b\)</span>至少存在一个公共质因子</p><p>于是乎，上面问题可以进一步转化：对<spanclass="math inline">\(y-x\)</span>进行质因子分解(欧拉筛法(线性))，假设枚举<spanclass="math inline">\(y-x\)</span>的一个质因子为<spanclass="math inline">\(p\)</span>,</p><p>则：<span class="math inline">\(t\)</span>的可能取值就是满足<spanclass="math inline">\((x+t)\%p=0\)</span>的<spanclass="math inline">\(t\)</span>，即有：<spanclass="math inline">\(t=(-x)\%p\)</span></p><p>对所有可能的<spanclass="math inline">\(t\)</span>取最小，即得到最小的<spanclass="math inline">\(t\)</span>的取值，由此幸运链的长度为<spanclass="math inline">\(t\)</span>,答案<spanclass="math inline">\(res=t\)</span></p><h3 id="解题代码-3">解题代码</h3><blockquote><p>注意要打消<code>iostream</code>的输入和输出缓存，节省时间,否则会<spanclass="math inline">\(TLE\)</span></p><p>设置如下：</p><p><code>std::ios::sync_with_stdio(false);</code><code>std::cin.tie(0);</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">2e9</span>;<br><span class="hljs-type">int</span> minp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">euler</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>  bitset&lt;N&gt; vis;<br>  vector&lt;ll&gt; p;<br>  vis[<span class="hljs-number">0</span>]=vis[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>  minp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>      p.<span class="hljs-built_in">push_back</span>(i);<br>      minp[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;i*p[j]&lt;=n&amp;&amp;j&lt;p.<span class="hljs-built_in">size</span>();j++)&#123;<br>      vis[i*p[j]]=<span class="hljs-literal">true</span>;<br>      minp[i*p[j]]=p[j];<br>      <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ll x,y;<br>  cin&gt;&gt;x&gt;&gt;y;<br>  y-=x;<br>  ll res=INF;<br>  <span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) res=<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">1</span>)&#123;<br>      ll p=minp[y];<br>      res=<span class="hljs-built_in">min</span>(res,((-x)%p+p)%p);<br>      <span class="hljs-keyword">while</span>(y%p==<span class="hljs-number">0</span>) y/=p;<br>    &#125;<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">euler</span>(<span class="hljs-number">1e7</span>);<br>  <span class="hljs-type">int</span> t;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2id="binary-string"><a href="https://codeforces.com/problemset/problem/1680/C" target="_blank">BinaryString</a></h2><h3 id="题意-4">题意</h3><p>给定一个01字符串 <span class="math inline">\(s\)</span>，你需要选取<span class="math inline">\(s\)</span> 中的一个子串 <spanclass="math inline">\(t\)</span> ，最小化<spanclass="math inline">\(max(字串中0的个数,s中1的个数-子串t中1的个数)\)</span></p><h3 id="解题思路-4">解题思路</h3><p>设<span class="math inline">\(t_0\)</span>：子串<spanclass="math inline">\(t\)</span>中<spanclass="math inline">\(0\)</span>的个数，<spanclass="math inline">\(t_1\)</span>:子串<spanclass="math inline">\(t\)</span>中<spanclass="math inline">\(1\)</span>的个数，<spanclass="math inline">\(s_1\)</span>:字符串<spanclass="math inline">\(s\)</span>中1的个数</p><p><spanclass="math inline">\(max(字串中0的个数,s中1的个数-子串t中1的个数)=max(t_0,s_1-t_1)=max(t_0+t_1,s_1)-t_1=max(len,s_1)-t_1\)</span>(<spanclass="math inline">\(len\)</span>为子串长度)</p><ul><li>当<span class="math inline">\(len \le s_1\)</span>时，<spanclass="math inline">\(max(len,s_1)-t_1=s_1-t_1\)</span></li></ul><p>由于求最小值，因此要将其最小化，<spanclass="math inline">\(s_1\)</span>为定值，我们需要<spanclass="math inline">\(t_1\)</span>尽可能大(子串中<spanclass="math inline">\(1\)</span>的数量尽可能多)，而随着<spanclass="math inline">\(len\)</span>增大，<spanclass="math inline">\(t_1\)</span>增大，故我们选择<spanclass="math inline">\(len=s_1\)</span></p><ul><li>当<span class="math inline">\(len \ge s_1\)</span>时，<spanclass="math inline">\(max(len,s_1)-t_1=len-t_1=t_0\)</span></li></ul><p>由于求最小值，因此要将其最小化，我们需要<spanclass="math inline">\(t_0\)</span>尽可能小(子串中0的数量尽可能少)，而随<spanclass="math inline">\(len\)</span>增大，<spanclass="math inline">\(t_0\)</span>增大，故我们选择<spanclass="math inline">\(len=s_1\)</span></p><p><strong>由此，最终我们只需枚举子串的右端点<spanclass="math inline">\(r(r\ge len)\)</span>,左端点<spanclass="math inline">\(l\)</span>取<spanclass="math inline">\(r-len=r-s_1\)</span>,同时子串<spanclass="math inline">\([l,r]\)</span>中<spanclass="math inline">\(0\)</span>的数量可以用前缀和维护</strong></p><p><strong>答案即为：<spanclass="math inline">\(res=min(t_0)\)</span></strong></p><h3 id="解题代码-4">解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  string s;<br>  cin&gt;&gt;s;<br>  <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>  s=<span class="hljs-string">&#x27;?&#x27;</span>+s;<br>  <span class="hljs-type">int</span> sum=<span class="hljs-built_in">count</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">//计算s中1的数量</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<span class="hljs-comment">//前缀和用于维护子串中0的数量</span><br>    pre[i]=pre[i<span class="hljs-number">-1</span>]+(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> res=sum;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sum;i&lt;=len;i++)&#123;<span class="hljs-comment">//枚举右端点</span><br>    res=<span class="hljs-built_in">min</span>(res,pre[i]-pre[i-sum]);<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> t;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces(rating 1200-1600)思维题训练题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
