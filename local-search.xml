<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Codeforces-Global-Round-25</title>
    <link href="/2024/04/22/cf-global-round-25/"/>
    <url>/2024/04/22/cf-global-round-25/</url>
    
    <content type="html"><![CDATA[<h2 id="C-Ticket-Hoarding"><a href="#C-Ticket-Hoarding" class="headerlink" title="C. Ticket Hoarding"></a><a href="https://codeforces.com/contest/1951/problem/C">C. Ticket Hoarding</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为$n$ 的<strong>正整数</strong>数组 $a$，求一个<strong>正整数</strong>数组 $b$在满足$\sum_{i=1}^{n} b_i$=k的条件下，求$\sum_{i=1}^n b_i(a_i + \sum_{j=1}^{i-1}b_i)$的最小值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将上述式子进行变形：</p><script type="math/tex; mode=display">\begin{align*} \sum_{i=1}^n b_i(a_i + \sum_{j=1}^{i-1}b_i) &= \sum_{i=1}^n a_i b_i + \sum_{i=1}^n \sum_{j=1}^{i-1}b_i \\&= \sum_{i=1}^n a_i b_i + \frac{1}{2}(\sum_{i=1}^n b_i)^2 - \frac{1}{2}\sum_{i=1}^n b_i^2 \\&= \sum_{i=1}^n (a_i-\frac{1}{2}b_i)b_i + \frac{1}{2} k^2 \\&= \frac{1}{2}\sum_{i=1}^n (a_i^2-(b_i-a_i)^2) +\frac{1}{2} k^2 \\&= -\frac{1}{2} \sum_{i=1}^n (b_i-a_i)^2 + \frac{1}{2}\sum_{i=1}^n a_i^2 + \frac{1}{2} k^2 \end{align*}</script><p>故要使上式值最小，则应使$\sum_{i=1}^n (b_i-a_i)^2$尽可能的大，而要使$\sum_{i=1}^n (b_i-a_i)^2$尽可能的大，</p><p>等价于：较小的$a_i$尽可能匹配较大的$b_i$，较大的$a_i$尽可能匹配较小的$b_i$</p><p>由此可通过将$a$进行排序(从小到大)，将$b$的前$\lfloor\frac{k}{m}\rfloor$项置$m$，第$\lfloor\frac{k}{m}\rfloor+1$项置$k%m$,后面全置$0$，可得到最优解</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n,m,k;<br>  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>  <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>  ll ans=<span class="hljs-number">1ll</span>*k*k;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k&gt;=m)&#123;<br>      ans-=<span class="hljs-number">1ll</span>*(m-a[i])*(m-a[i]);<br>      k-=m;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>      ans-=<span class="hljs-number">1ll</span>*(k-a[i])*(k-a[i]);<br>      k=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> ans-=<span class="hljs-number">1ll</span>*a[i]*a[i];<br>    ans+=<span class="hljs-number">1ll</span>*a[i]*a[i];<br>  &#125;<br>  cout&lt;&lt;ans/<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces(1200-1400)训练</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>思维题训练5</title>
    <link href="/2023/11/24/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%835/"/>
    <url>/2023/11/24/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%835/</url>
    
    <content type="html"><![CDATA[<h2 id="Hamon-Odyssey"><a href="#Hamon-Odyssey" class="headerlink" title="Hamon Odyssey"></a><a href="https://codeforces.com/contest/1847/problem/B" target="_blank">Hamon Odyssey</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为$n$的数组$a$，请你将数组划分为若干<strong>连续的段</strong>，<strong>要求每一段的逻辑与的结果之和最小</strong>，<strong>问最多划分为多少段</strong></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据位与性质：<strong>连续位与操作只会让结果不变或变小</strong></p><p>由此我们可以得出结论：每一段的逻辑与的结果之和的最小值=将整个数组相与的结果</p><ul><li>若这个最小值大于$0$，则最多划分成$1$段(<strong>因为如果划分成多个段必然会使结果变大</strong>)</li><li>若这个最小值等于$0$，可以采取贪心策略的去划分尽可能多的段：如果一段逻辑与结果为$0$，立即切断，若最后一段不为$0$，则将其并到其前面一段中(因为$0\And x=0$)，这样可以保证最终的结果为$0$</li></ul><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-type">int</span> sum=a[<span class="hljs-number">1</span>],res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        sum&amp;=a[i];<br>        <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>) res++,sum=a[i+<span class="hljs-number">1</span>];<span class="hljs-comment">//切断操作</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!res) res++;<span class="hljs-comment">//如果最后一段不为0，并入前一段中</span><br>    cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="And"><a href="#And" class="headerlink" title="And"></a><a href="https://codeforces.com/contest/1013/problem/B" target="_blank">And</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n(n≤100000)$ 的序列 $a_i(a_i≤100000)$，并给定一个数 $x(x≤100000) $<br>每一步可以将序列中的一个数与上 $x$<br>求使序列中出现两个相等的数的最小步数。如果不可能则输出 $−1$</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据位与性质：$a_i\And x\And x \And \cdots \And x=\begin{cases}a_i &amp;a_i=a_i\And x\\a_i\And x &amp;a_i\neq a_i \And x\end{cases}$</p><p>因此最多可以分为四种情况：</p><ul><li>步数为$0$:原序列中本身存在相等的数</li><li>步数为$1$:原序列存在一个数，与变换后的序列($a_i=a_i\And x(1\le i\le n)$)中的数相等，同时要求$a_i\ne a_i \And x$</li><li>步数为$2$:变换后的序列中存在相等的数</li><li>步数为$-1$(即:不存在)：上述情况均不满足</li></ul><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; ma,mb;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        ma[a[i]]++,mb[a[i]&amp;x]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ma[a[i]]&gt;=<span class="hljs-number">2</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ma[a[i]&amp;x]&amp;&amp;(a[i]&amp;x)!=a[i])&#123;<br>            cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:mb)&#123;<br>        <span class="hljs-keyword">if</span>(it.second&gt;=<span class="hljs-number">2</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="M-arrays"><a href="#M-arrays" class="headerlink" title="M-arrays"></a><a href="https://codeforces.com/problemset/problem/1497/B" target="_blank">M-arrays</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给你一个长度为$n$的数组$a$和一个整数$m$</p><p>可以将这个数组的元素分成几个新的数组</p><p>在新数组中，可以改变需要排列元素的顺序，要求新数组中的相邻元素$b_i,b_i+1$必须满足$(b_i+b_{i+1})\%m=0$</p><p>求满足条件的新数组的<strong>最小个数</strong></p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>$(b_i+b_{i+1})\%m=0 \Longleftrightarrow b_i\%m+b_{i+1}\%m=m(b_i\ge 0,0\le i &lt; n)$</p><p>由此，得出我们的最佳分组策略：</p><ul><li>将$b_i\%m=0$的数或者$b_i\%m=m/2(m为偶数)$的数需单独分入一个组中</li><li>将$b_i\%m=x$的数(记其数量为：$num_x\ne0$)和$b_i\%m=m-x$的数(记其数量为：$num_y\ne 0$)放入同一组中，放入形式形如:$x,y,x,y,x(num_x&gt;num_y)$这样交替排列，<strong>剩余不能放入$x,y$交替排列的组的数只能单个成组</strong>，最终可以推出由$x$,$y$构成的最小组数$cnt=\begin{cases}|num_x-num_y| &amp;num_x\ne num_y\\1 &amp;num_x=num_y\end{cases}$</li><li>不满足上述两种条件的其他元素均需单独成组</li></ul><p>我们将数组中的元素中模上$m$放入结果为$0,1,\cdots,m-1$的桶中</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(m+<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        num[x%m]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">if</span>((i==<span class="hljs-number">0</span>||i*<span class="hljs-number">2</span>==m)&amp;&amp;num[i]) res++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[i])&#123;<br>            <span class="hljs-keyword">if</span>(num[m-i]) <br>            res+=num[m-i]!=num[i]?<span class="hljs-built_in">abs</span>(num[m-i]-num[i]):<span class="hljs-number">1</span>,num[m-i]=num[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> res+=num[i];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Flip-the-Bits"><a href="#Flip-the-Bits" class="headerlink" title=" Flip the Bits"></a><a href="https://codeforces.com/contest/1504/problem/B" target="_blank"> Flip the Bits</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定长度为$n$的$01$串$a,b$中，可以进行操作: 当前缀中$0$与$1$的个数相等时，可以将前缀进行翻转($0\rightarrow 1$，$1\rightarrow 0$)，问是否通过若干个操作使得$a\rightarrow b$</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以考虑通过将$a,b$字符串进行按位异或,得到字符串$c$(若$c_i=0$,则说明$i$位置$a_i\ne b_i$，反之则说明$a_i=b_i$)</p><p>若前缀能翻转：</p><ul><li>翻转后不影响前缀中$0,1$的相对数量，意味着能翻转的前缀永远能翻转，不能翻转的前缀永远不能翻转</li><li>翻转后不影响字符串前缀之后的字符，翻转大前缀必然影响小前缀</li></ul><p>初始前缀中元素被翻转的次数$sum=0$</p><p>从后往前遍历(翻转后面的必然影响前面的字符)：</p><ul><li>若$!(sum\%2\ XOR \ c[i])=true$(说明之前的翻转使得$c_i=1$)，则需将以$i$结尾的前缀翻转，若不能翻转(判断前缀是否能翻转可以进行预处理出前缀中$0$与$1$的数量是否相等)，则说明$a$不能变换成$b$,反之，则$sum++$(表示$i$前面的字符翻转次数将增加$1$)</li><li>反之，则跳过</li></ul><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    string s,t;<br>    cin&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span>,<span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x=s[i]-<span class="hljs-string">&#x27;0&#x27;</span>,y=t[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        a[i]=x^y;<br>        cnt+=x;<br>        flag[i]=(<span class="hljs-number">2</span>*cnt==i+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(!(a[i]^(sum%<span class="hljs-number">2</span>))) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!flag[i])&#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        sum++;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Find-The-Array"><a href="#Find-The-Array" class="headerlink" title="Find The Array"></a><a href="https://codeforces.com/contest/1550/problem/A" target="_blank">Find The Array</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为$n$的数组$a$，$S=\sum_{i=1}^{n}a_i$，试构造一个$b$数组，同时满足：</p><ul><li>$b_i|b_i+1$或$b_{i+1}|b_i$</li><li>$2\sum_{i=1}^{n}|a_i-b_i|\le S$</li></ul><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以构造$b$数组各元素之间呈$2^k$的倍数关系，即可满足：($b_i|b_{i+1}$或$b_{i+1}|b_i$)，$b_i$选取为离$a_i$最近的$2^t$,即满足$|a_i-b_i|\le a_i\Longrightarrow 2\sum_{ i=1}^{n}|a_i-b_i|\le S$</p><h3 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(res&lt;x) res&lt;&lt;=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res&gt;&gt;<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        ll x;<br>        cin&gt;&gt;x;<br>        cout&lt;&lt;<span class="hljs-built_in">f</span>(x)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces(rating 1200-1600)思维题训练题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp</title>
    <link href="/2023/11/09/kmp/"/>
    <url>/2023/11/09/kmp/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="$KMP$算法"></a>$KMP$算法</h2><blockquote><p>求解给定一个模式串$P$和一个主串$S$，求模式串$P$在主串$S$中出现的位置(字符串的下标均从1开始)</p></blockquote><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>取最长的相等前后缀，可以保证不漏解</li><li>通过模式串前后缀的自我匹配的长度，计算$next$函数，给$j$指针打一张表，失配时就跳到$next[j]$的位置继续匹配</li></ol><blockquote><p>$next$函数：$next[i]$表示模式串$P[1,i]$中相等前后缀的最长长度</p></blockquote><h3 id="如何计算-next-函数"><a href="#如何计算-next-函数" class="headerlink" title="如何计算$next$函数"></a><strong>如何计算$next$函数</strong></h3><blockquote><p>双指针：$i$扫描模式串，$j$扫描前缀</p><p>初始化：$ne[i]=0,i=2,j=0$</p><ol><li>若$P[i]\ne P[j+1]$，让$j$回跳能匹配的位置，如果找不到能匹配的位置，$j$回跳到$0$</li><li>若$P[i]=P[j+1]$，让$j++$,指向匹配前缀的末尾</li><li>$next[i]$等于$j$的值</li></ol></blockquote><h3 id="计算-next-函数模板"><a href="#计算-next-函数模板" class="headerlink" title="计算$next$函数模板"></a>计算$next$函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ne[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>    <span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>    ne[i]=j;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><blockquote><p>$j$指针所走的总步数就决定了总的执行次数</p><p>每轮$for$循环，$j$至多$+1$，那么$j$一共向右至多走$n$步，往左跳的步数加起来不会超过$n$步，否则$j$变为负数</p><p>故$j$的总步数不会超过$2n$，所以时间复杂度为$O(n)$</p></blockquote><h3 id="KMP-模式串与主串匹配算法模板"><a href="#KMP-模式串与主串匹配算法模板" class="headerlink" title="$KMP$模式串与主串匹配算法模板"></a>$KMP$模式串与主串匹配算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>    <span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>    <span class="hljs-keyword">if</span>(j==n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-n+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2023/11/09/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2023/11/09/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-双指针理论部分"><a href="#1-双指针理论部分" class="headerlink" title="1.双指针理论部分"></a>1.双指针理论部分</h2><p>双指针是一个常用的优化技巧，是一种通过设置两个指针不断进行单向移动用来解决<strong>序列的区间问题</strong></p><p>两个指针$i,j$，有两种扫描方向：</p><ol><li>同向扫描(快慢指针)：$i,j$方向相同，都从头到尾，一个走的慢，一个走快</li><li>反向扫描:$i,j$方向相反，一个从头到尾，一个从尾到头，在中间相会</li></ol><p><strong>双指针的核心：找单调关系：$i$和$j$的之间关系</strong></p><h3 id="1-如何判断一个题目是否可以用双指针来解"><a href="#1-如何判断一个题目是否可以用双指针来解" class="headerlink" title="(1)如何判断一个题目是否可以用双指针来解"></a>(1)如何判断一个题目是否可以用双指针来解</h3><ol><li><p>因为双指针算法是一种优化时间复杂度的方法，所以我们可以首先写出最朴素的<strong>两层循环</strong>的写法。</p></li><li><p>然后考虑题目中是否具有<strong>单调性</strong>。</p></li></ol><p><strong>即当其中一个指针$i$向后移动时，在希望得到答案的情况下，另一个指针$j$是不是只能向着一个方向移动。</strong></p><ol><li>如果是，说明题目具有单调性，可以通过<strong>双指针算法优化</strong>。</li></ol><h3 id="2-双指针模板"><a href="#2-双指针模板" class="headerlink" title="(2)双指针模板"></a>(2)双指针模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&lt;i&amp;&amp;<span class="hljs-built_in">check</span>(i,j)) j++;<br>    <span class="hljs-comment">//每道题目具体逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-双指针题目题解"><a href="#2-双指针题目题解" class="headerlink" title="2.双指针题目题解"></a>2.双指针题目题解</h2><h3 id="1-最长连续不重复子序列"><a href="#1-最长连续不重复子序列" class="headerlink" title="(1).最长连续不重复子序列 "></a>(1).<a href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列 </a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个长度为 $n$ 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>假设区间$[j,i]$是以$i$为终点的最长连续不重复子序列</p><p>不难发现，若$i$向后移动($eg:i+1$)，$j$只会向后或不移动，$j$不可能往前移动</p><p>证明如下：</p><p>假设 $[j,i]$ 是以$i$ 为终点的最长连续不重复子序列。如果当$i$ 向后移动时(比如到 $i+1$)，$j$却向前移动了(比如到 $j−1$)。<br>说明 $[j−1,i+1]$ 是以 $i+1$ 为终点的<strong>最长连续不重复子序列</strong>，换句话说：$[j−1,i+1]$ 范围内都<strong>没有重复元素</strong>。<br>即：以 $i$ 为终点的最长连续不重复子序列应该是 $[j−1,i]$ 而不是 $[j,i]$，与假设相矛盾<br>因此可证明：<br><strong>当$i$向后移动时，$j$不可能向前移动 （可能不动，也可以向后，就是不可能向前）</strong></p><p><strong>由此我们可以用双指针在$O(n)$时间复杂度解决该问题</strong></p><h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">100010</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        num[a[i]]++;<br>        <span class="hljs-keyword">while</span>(j&lt;i&amp;&amp;num[a[i]]&gt;<span class="hljs-number">1</span>) num[a[j]]--,j++;<br>        res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Xor-Sum-2"><a href="#2-Xor-Sum-2" class="headerlink" title="(2).Xor Sum 2"></a>(2).<a href="https://atcoder.jp/contests/arc098/tasks/arc098_b">Xor Sum 2</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一数组，求出满足$a_l+\cdots+a_r=a_l \wedge \dots \wedge a_r$$l \le r$的$(l,r)$的数量</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>假设$[l,r]$为满足题意的最大区间：满足$a_l+\cdots+a_r=a_l \wedge \dots \wedge a_r$</p><p>当$r$增大时，则有$a_l+\cdots+a_r&gt;a_l \wedge \dots \wedge a_r$，<strong>由于异或和是不进位的加法，有</strong>$a_i+a_j \ge a_i \wedge a_j$，只有$l$增大才能使得$a_l+\cdots+a_r=a_l \wedge \dots \wedge a_r$</p><p>原因：当$l$减小($eg:l-1$)时，根据性质$a_i+a_j \ge a_i \wedge a_j$，$a_{l-1}+(a_l+\cdots+a_r)&gt;a_{l-1} \wedge (a_l\wedge \cdots a_r)$恒成立</p><h4 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>  ll sum=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;<br>  ll res=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j+<span class="hljs-number">1</span>&lt;=n&amp;&amp;sum+a[j+<span class="hljs-number">1</span>]==(x^a[j+<span class="hljs-number">1</span>]))&#123;<br>      j++;<br>      sum+=a[j];<br>      x^=a[j];<br>    &#125;<br>    res+=j-i+<span class="hljs-number">1</span>;<br>    sum-=a[i];<br>    x^=a[i];<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-连续自然数和"><a href="#3-连续自然数和" class="headerlink" title="(3).连续自然数和 "></a>(3).<a href="https://www.luogu.com.cn/problem/P1147" target="_blank">连续自然数和 </a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>对一个给定的正整数 <em>M</em>，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 <em>M</em>。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>假设$[l,r]$为满足连续自然数之和$sum==M$的区间，则当$r$增大时，则有该连续自然数之和$sum&gt;M$</p><ul><li><p>当$l$减小时，$sum$增大，$sum&gt;M$恒成立</p></li><li><p>当$l$增大时，$sum$减小，$sum==M$可能成立</p></li></ul><p>因此$l$随着$r$的增大而增大，满足单调性，可以使用双指针算法解决此题</p><h4 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;r&lt;m;r++)&#123;<br>        sum+=r;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;sum&gt;m)&#123;<br>            sum-=l,l++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum==m) <br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>codeforces思维题训练1</title>
    <link href="/2023/10/21/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%831/"/>
    <url>/2023/10/21/%E6%80%9D%E7%BB%B4%E9%A2%98%E8%AE%AD%E7%BB%831/</url>
    
    <content type="html"><![CDATA[<h2 id="Consecutive-Points-Segment"><a href="#Consecutive-Points-Segment" class="headerlink" title="Consecutive Points Segment"></a><a href="https://codeforces.com/problemset/problem/1671/b" target="_blank">Consecutive Points Segment</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在 $X$轴上给出 $N$ 个横坐标,每个点可以变为$x_i-1$,$x_i$,$x_i+1$,问该序列最后是否可以变为一个接续序列</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于一段接续的点要保证其连续性，就必须将<strong>这段接续的点作为一个整体</strong>全部向左移动一格或向右移动一格</p><p>因此，在$X$轴可以划分出若干条线段(各线段中间以<strong>空隙点</strong>将线段隔开)，并且<strong>最左侧线段最多只能右移一格，不能左移，最多能使空隙点数量减一，最右侧线段最多只能左移一格，不能右移，最多使空隙点数量减一</strong>，<strong>而移动中间线段将不改变空隙点数量</strong></p><p><strong>当空隙点数量为0时即认为序列变为一个接续序列</strong></p><p><strong>故只要$X$轴的空隙点数量小于等于$2$,就一定可以操作使序列变为接续序列，反之则不行</strong></p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>  <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录空隙点数量</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    ans+=(a[i]-a[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(ans&lt;=<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>  <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> t;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题后思考"><a href="#题后思考" class="headerlink" title="题后思考"></a>题后思考</h3><ul><li>在考虑单点操作时，可以将其多个点的共同操作，并且遵守某个原则(该题就是遵守保持接续性原则)</li><li>并且每次操作产生的影响，尽量用一个可以<strong>量化的东西来表达</strong>(该题中可以量化的东西为空隙点的数量)</li></ul><h2 id="Make-it-Increasing"><a href="#Make-it-Increasing" class="headerlink" title="Make it Increasing"></a><a href="https://codeforces.com/problemset/problem/1667/a " target="_blank">Make it Increasing</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为$n$的数组$a$，一个初始化全为$0$长度亦为$n$的数组$b$</p><p>可以进行操作：每次可以选择一个下标$i$进行如下操作的其中一个</p><ul><li>$b[i]+=a[i]$</li><li>$b[i]-=a[i]$</li></ul><p>求使数组$b$变为<strong>严格单增序列</strong>需操作的<strong>最少次数</strong></p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>观察本题数据量不超过$5000$，因此支持$O(n^2)$做法</p><p>而要使$b$数组变为严格单增序列且操作次数最少，必然肯定存在一个点$k$，$[1,k]$区间进行减法操作，$[k+1,n]$进行加法操作</p><p><strong>那么$c$数组中必然存在一个$0$</strong></p><p>因此我们通过枚举$0$的位置，假设$0$所在的位置为$k$，在$[1,k-1]$进行减法操作保证左侧递增，记进行减法操作的数量为$ans$，在$[k+1,n]$进行加法操作保证右侧递增,记进行加法操作的数量为$bns$</p><p>最终答案为$res=max(ans+bns)$</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span><span class="hljs-comment">//数据量小,暴力枚举位置计算即可，时间复杂度为：O(n^2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>  cin&gt;&gt;a[i];<br>  ll res=<span class="hljs-number">1e18</span>,ans=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;pos&lt;n;pos++)&#123;<br>    <span class="hljs-comment">//初始化b数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) b[i]=<span class="hljs-number">0</span>;<br>    ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//答案</span><br>    <span class="hljs-comment">//左边递减</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>      ll d=b[i+<span class="hljs-number">1</span>]-b[i];<br>      ll k=(d+a[i])/a[i];<span class="hljs-comment">//递减倍数</span><br>      b[i]=k*a[i];<br>      ans+=k;<br>    &#125;<br>    <span class="hljs-comment">//右边递增</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos+<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>      ll d=b[i<span class="hljs-number">-1</span>]-b[i];<br>      ll k=(d+a[i])/a[i];<span class="hljs-comment">//递增倍数</span><br>      b[i]=k*a[i];<br>      ans+=k;<br>    &#125;<br>    res=<span class="hljs-built_in">min</span>(res,ans);<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Permutation"><a href="#Permutation" class="headerlink" title="Permutation"></a><a href="https://codeforces.com/problemset/problem/359/B" target="_blank">Permutation</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定$n,k$，构造一个排列使得$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=2k$</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于构造排列，排列无非就三种：<strong>递增排列，递减排列，摆动排列</strong></p><p><strong>思考问题一般习惯从特殊一般来考虑</strong></p><ul><li>考虑特殊：</li></ul><p>假设$a$为递增排列，那么$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=0$</p><p>假设$a$为递减排列，那么$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=0$</p><ul><li>考虑一般：将特殊排列中的任意几个数调换位置即变为摆动摆列</li></ul><p>我们发现：</p><p>假设$a$为递增排列，当每将一对$a_{2i-1},a_{2i}$调换位置，将使得$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|$减少$2$</p><p>假设$a$为递减排列，当每将一对$a_{2i-1},a_{2i}$调换位置，将使得$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|$增加$2$</p><p>故要使得$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=2k$</p><p>我们可以先使序列为递减序列，然后在此基础上选择k对$a_{2i-1},a_{2i}$调换位置，即可使得$\sum_{i=1}^n|a_{2i-1}-a_{2i}|-|\sum_{i=1}^{n}a_{2i-1}-a_{2i}|=2k$</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n,k;<br>  cin&gt;&gt;n&gt;&gt;k;<br>  vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>*n);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++) a[i]=<span class="hljs-number">2</span>*n-i;<span class="hljs-comment">//初始为递减序列</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">2</span>*i],a[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>]);<span class="hljs-comment">//交换a[2*i],a[2*i+1]使式子等于2*k</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;i++)<br>  cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>  cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lucky-Chains"><a href="#Lucky-Chains" class="headerlink" title="Lucky Chains"></a><a href="https://codeforces.com/problemset/problem/1766/D" target="_blank">Lucky Chains</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>定义二元组$(x,y)$是幸运的当且仅当$gcd(x,y)=1$</p><p>定义由$(x,y)$起始长度为$k$的幸运链，当且仅当$gcd(x+i,y+i)=1(0\le i \le k)$恒成立</p><p>若给定一个二元组$(x,y)$,求由它生成的最长幸运链的最长长度(若长度可以为$\infty$，答案记为$-1$)</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设从$(x,y)$开始，中间均是幸运的，直到$(x+t,y+t)$不幸运即：$gcd(x+t,y+t)\ne 1$</p><p>利用性质$gcd(a,b)=gcd(a,b-a)$可得：</p><p>$gcd(x+t,y+t)=gcd(x+t,y-x)$</p><p>易知：当$x-y=1$时，$t=\infty$,答案$res=-1$</p><p>当$x-y \ne 1$时，则转变求$t$的最小值</p><p>当$gcd(a,b)\ne 1$时，那么$a,b$至少存在一个公共质因子</p><p>于是乎，上面问题可以进一步转化：对$y-x$进行质因子分解(欧拉筛法(线性))，假设枚举$y-x$的一个质因子为$p$,</p><p>则：$t$的可能取值就是满足$(x+t)\%p=0$的$t$，即有：$t=(-x)\%p$</p><p>对所有可能的$t$取最小，即得到最小的$t$的取值，由此幸运链的长度为$t$,答案$res=t$</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><blockquote><p>注意要打消<code>iostream</code>的输入和输出缓存，节省时间,否则会$TLE$</p><p>设置如下：</p><p><code>std::ios::sync_with_stdio(false);</code><br>    <code>std::cin.tie(0);</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">2e9</span>;<br><span class="hljs-type">int</span> minp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">euler</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>  bitset&lt;N&gt; vis;<br>  vector&lt;ll&gt; p;<br>  vis[<span class="hljs-number">0</span>]=vis[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>  minp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>      p.<span class="hljs-built_in">push_back</span>(i);<br>      minp[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;i*p[j]&lt;=n&amp;&amp;j&lt;p.<span class="hljs-built_in">size</span>();j++)&#123;<br>      vis[i*p[j]]=<span class="hljs-literal">true</span>;<br>      minp[i*p[j]]=p[j];<br>      <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ll x,y;<br>  cin&gt;&gt;x&gt;&gt;y;<br>  y-=x;<br>  ll res=INF;<br>  <span class="hljs-keyword">if</span>(y==<span class="hljs-number">1</span>) res=<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">while</span>(y&gt;<span class="hljs-number">1</span>)&#123;<br>      ll p=minp[y];<br>      res=<span class="hljs-built_in">min</span>(res,((-x)%p+p)%p);<br>      <span class="hljs-keyword">while</span>(y%p==<span class="hljs-number">0</span>) y/=p;<br>    &#125;<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">euler</span>(<span class="hljs-number">1e7</span>);<br>  <span class="hljs-type">int</span> t;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Binary-String"><a href="#Binary-String" class="headerlink" title="Binary String"></a><a href="https://codeforces.com/problemset/problem/1680/C" target="_blank">Binary String</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定一个01字符串 $s$，你需要选取 $s$ 中的一个子串 $t$ ，最小化$max(字串中0的个数,s中1的个数-子串t中1的个数)$</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>设$t_0$：子串$t$中$0$的个数，$t_1$:子串$t$中$1$的个数，$s_1$:字符串$s$中1的个数</p><p>$max(字串中0的个数,s中1的个数-子串t中1的个数)=max(t_0,s_1-t_1)=max(t_0+t_1,s_1)-t_1=max(len,s_1)-t_1$($len$为子串长度)</p><ul><li>当$len \le s_1$时，$max(len,s_1)-t_1=s_1-t_1$</li></ul><p>由于求最小值，因此要将其最小化，$s_1$为定值，我们需要$t_1$尽可能大(子串中$1$的数量尽可能多)，而随着$len$增大，$t_1$增大，故我们选择$len=s_1$</p><ul><li>当$len \ge s_1$时，$max(len,s_1)-t_1=len-t_1=t_0$</li></ul><p>由于求最小值，因此要将其最小化，我们需要$t_0$尽可能小(子串中0的数量尽可能少)，而随$len$增大，$t_0$增大，故我们选择$len=s_1$</p><p><strong>由此，最终我们只需枚举子串的右端点$r(r\ge len)$,左端点$l$取$r-len=r-s_1$,同时子串$[l,r]$中$0$的数量可以用前缀和维护</strong></p><p><strong>答案即为：$res=min(t_0)$</strong></p><h3 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  string s;<br>  cin&gt;&gt;s;<br>  <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>  s=<span class="hljs-string">&#x27;?&#x27;</span>+s;<br>  <span class="hljs-type">int</span> sum=<span class="hljs-built_in">count</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">//计算s中1的数量</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<span class="hljs-comment">//前缀和用于维护子串中0的数量</span><br>    pre[i]=pre[i<span class="hljs-number">-1</span>]+(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> res=sum;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sum;i&lt;=len;i++)&#123;<span class="hljs-comment">//枚举右端点</span><br>    res=<span class="hljs-built_in">min</span>(res,pre[i]-pre[i-sum]);<br>  &#125;<br>  cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> t;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces(rating 1200-1600)思维题训练题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
